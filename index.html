<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Poker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom Styles from User - Adjusted slightly */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            overflow: hidden; /* Prevent scrollbars from table extending */
        }
        .poker-table {
            background-color: #047857; /* Green felt */
            border-radius: 50%; /* Oval shape */
            width: 90vw;
            max-width: 1000px;
            height: 50vw; /* Aspect ratio for oval */
            max-height: 550px;
            border: 10px solid #4a332a; /* Wooden rail */
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
         /* Winner Display Area */
         #winner-display {
            position: absolute;
            top: 65%; /* Position below pot area */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: #fcd34d; /* Gold text */
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #fcd34d;
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
            z-index: 20; /* Above player areas */
            display: none; /* Hidden by default */
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            max-width: 80%;
        }
         #winner-display p { margin: 2px 0; }
         #winner-display .hand-rank { font-size: 0.9em; color: #e2e8f0; font-weight: normal;}

        .player-area {
            position: absolute;
            transform: translate(-50%, -50%); /* Center based on position */
            width: 120px; /* Fixed width for player area */
            text-align: center;
            background-color: rgba(0, 0, 0, 0.4); /* Slightly darker bg */
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: border-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition for highlight */
            z-index: 1; /* Ensure player areas are below winner display */
        }
        /* Player Positions (Adjust as needed for 8 players) */
        .player-pos-0 { top: 88%; left: 50%; } /* Bottom center */
        .player-pos-1 { top: 75%; left: 78%; } /* Bottom right */
        .player-pos-2 { top: 50%; left: 90%; } /* Right */
        .player-pos-3 { top: 25%; left: 78%; } /* Top right */
        .player-pos-4 { top: 12%; left: 50%; } /* Top center */
        .player-pos-5 { top: 25%; left: 22%; } /* Top left */
        .player-pos-6 { top: 50%; left: 10%; } /* Left */
        .player-pos-7 { top: 75%; left: 22%; } /* Bottom left */

        .player-name {
            font-weight: bold;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #cbd5e1; /* Lighter name color */
        }
        .player-chips {
            font-size: 0.8rem;
            color: #a0aec0;
        }
        .player-cards {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-top: 4px;
            min-height: 40px; /* Ensure space for cards */
        }
        .card {
            background-color: white;
            color: black;
            border-radius: 4px;
            padding: 4px 2px;
            font-size: 1rem; /* Slightly larger card font */
            font-weight: bold;
            min-width: 28px; /* Slightly wider card */
            height: 40px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #ccc;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            user-select: none; /* Prevent text selection */
        }
        .card-back {
             /* Nicer card back pattern */
             background: repeating-linear-gradient(
                45deg,
                #606dbc,
                #606dbc 10px,
                #465298 10px,
                #465298 20px
            );
            color: transparent; /* Hide text if any */
            border: 1px solid #3b4a7a;
        }
        /* Suit colors */
        .card.heart, .card.diamond { color: #ef4444; } /* Red suits */
        .card.club, .card.spade { color: #1f2937; } /* Black suits */

        .community-card-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 8px;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            min-height: 60px; /* Ensure space */
            align-items: center;
        }
        .pot-area {
            position: absolute;
            top: 35%; /* Above community cards */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1rem;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5); /* Darker pot bg */
            color: #fcd34d; /* Gold color for pot */
            padding: 5px 15px;
            border-radius: 6px;
            z-index: 2; /* Above player areas if overlapping */
        }
        .action-area {
            margin-top: 20px;
            text-align: center;
            position: fixed; /* Keep actions visible */
            bottom: 15px; /* Slightly higher */
            left: 50%;
            transform: translateX(-50%);
            background-color: #2d3748;
            padding: 12px 20px; /* Adjusted padding */
            border-radius: 10px;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.4); /* Shadow on top */
            z-index: 10;
            display: flex; /* Use flexbox for buttons */
            gap: 10px; /* Space between buttons */
            align-items: center; /* Align items vertically */
        }
        .action-button {
            padding: 10px 18px; /* Adjusted padding */
            font-size: 0.95rem; /* Slightly smaller font */
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            border: none;
            min-width: 80px; /* Minimum button width */
            color: white; /* Default text color */
        }
        .action-button:disabled {
            background-color: #4a5568 !important; /* Ensure disabled style overrides */
            color: #a0aec0 !important;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .fold-button { background-color: #dc2626; }
        .fold-button:hover:not(:disabled) { background-color: #f87171; }
        .check-button { background-color: #2563eb; } /* Blue for check */
        .check-button:hover:not(:disabled) { background-color: #60a5fa; }
        .call-button { background-color: #fbbf24; color: #422006; } /* Amber for call */
        .call-button:hover:not(:disabled) { background-color: #fcd34d; }
        .bet-button, .raise-button { background-color: #16a34a; } /* Green for bet/raise */
        .bet-button:hover:not(:disabled), .raise-button:hover:not(:disabled) { background-color: #4ade80; }

        .bet-slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px; /* Space from buttons */
        }
        /* Custom Slider Appearance */
        input[type=range].bet-slider {
            width: 150px;
            height: 8px;
            cursor: pointer;
            background: #4a5568;
            border-radius: 5px;
            outline: none;
            appearance: none; /* Override default */
            -webkit-appearance: none;
        }
        /* Thumb */
        input[type=range].bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fcd34d; /* Gold thumb */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #422006;
        }
        input[type=range].bet-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #fcd34d;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #422006;
        }

        #bet-amount-label {
            min-width: 55px; /* Ensure space for amount */
            text-align: right;
            font-weight: bold;
            color: #fcd34d; /* Gold color */
            font-size: 0.9rem;
        }

        .message-log {
            position: fixed;
            bottom: 15px; /* Align with action area bottom */
            left: 15px;
            width: 280px; /* Wider log */
            height: 120px; /* Shorter log */
            background-color: rgba(45, 55, 72, 0.85); /* Slightly more opaque */
            border-radius: 8px;
            padding: 10px;
            font-size: 0.75rem; /* Smaller font */
            overflow-y: scroll;
            border: 1px solid #4a5568;
            z-index: 5;
            color: #a0aec0; /* Softer text color */
        }
        .message-log p {
            margin-bottom: 4px;
            word-wrap: break-word;
            line-height: 1.3;
        }
        .message-log p strong { font-weight: normal; }
         /* Highlight system/error messages */
         .message-log p.system-message strong { color: #a0aec0; }
         .message-log p.error-message strong { color: #f87171; } /* Red for errors */
         .message-log p.game-message strong { color: #60a5fa; } /* Blue for game messages */
         .message-log p.action-message strong { color: #fcd34d; } /* Gold for player actions */


        .player-status {
            font-style: italic;
            font-size: 0.75rem; /* Smaller status */
            margin-top: 2px;
            min-height: 1.2em; /* Reserve space */
            color: #fcd34d; /* Gold status text */
        }
        .player-area.player-current { /* More prominent highlight */
            border: 2px solid #fcd34d; /* Gold border */
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.7);
            z-index: 2; /* Bring current player above others slightly */
        }
        .player-area.player-dealer::after { /* Dealer button */
            content: 'D';
            position: absolute;
            top: -10px; /* Adjusted position */
            right: -10px;
            background-color: white;
            color: black;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #999;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .player-area.folded { /* Style for folded players */
            opacity: 0.6;
        }

        /* Modal for Name Input */
        #name-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px); /* Blur background */
        }
        #name-modal > div {
            background-color: #2d3748;
            padding: 30px 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #name-modal label { font-size: 1.1rem; margin-bottom: 10px; display: block; }
        #name-input {
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 20px;
            border-radius: 5px;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            color: #e2e8f0;
            width: 200px;
            text-align: center;
        }
        #name-submit {
            padding: 10px 25px;
            border-radius: 5px;
            background-color: #16a34a; /* Match bet button */
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }
        #name-submit:hover { background-color: #4ade80; }

        /* Hide elements initially */
        .action-area, .bet-slider-container { display: none; }

    </style>
</head>
<body>

    <div id="name-modal">
        <div>
            <label for="name-input">Enter your name:</label>
            <input type="text" id="name-input" maxlength="15"><br>
            <button id="name-submit">Join Game</button>
        </div>
    </div>

    <div class="poker-table" id="poker-table">
        <div id="winner-display">Winner Info Here</div>

        <div class="community-card-area" id="community-cards">
            <span class="text-gray-400 text-sm italic">Waiting for deal...</span>
        </div>

        <div class="pot-area" id="pot-area">
            Pot: $0
        </div>
        </div>

    <div class="action-area" id="action-area">
        <button class="action-button fold-button" id="fold-button">Fold</button>
        <button class="action-button check-button" id="check-button">Check</button>
        <button class="action-button call-button" id="call-button">Call $0</button>
        <button class="action-button bet-button" id="bet-button">Bet</button>
        <button class="action-button raise-button" id="raise-button">Raise to $0</button>

        <div class="bet-slider-container" id="bet-slider-container">
            <input type="range" id="bet-slider" class="bet-slider" min="0" max="1000" step="10" value="0">
            <span id="bet-amount-label">$0</span>
        </div>
    </div>

    <div class="message-log" id="message-log">
        <p class="system-message"><strong>System:</strong> Connecting...</p>
    </div>

    <script>
        const wsUrl = `ws://${window.location.hostname || 'localhost'}:8765`;
        let websocket = null;
        let myPlayerId = null;
        let myPlayerIndex = -1;
        let currentTurnOptions = null;
        let playerMap = {};
        let winnerDisplayTimeout = null;
        const WINNER_DISPLAY_DURATION = 5000; // ms

        // DOM Elements
        const nameModal = document.getElementById('name-modal');
        const nameInput = document.getElementById('name-input');
        const nameSubmit = document.getElementById('name-submit');
        const pokerTable = document.getElementById('poker-table');
        const communityCardArea = document.getElementById('community-cards');
        const potArea = document.getElementById('pot-area');
        const actionArea = document.getElementById('action-area');
        const messageLog = document.getElementById('message-log');
        const foldButton = document.getElementById('fold-button');
        const checkButton = document.getElementById('check-button');
        const callButton = document.getElementById('call-button');
        const betButton = document.getElementById('bet-button');
        const raiseButton = document.getElementById('raise-button');
        const betSliderContainer = document.getElementById('bet-slider-container');
        const betSlider = document.getElementById('bet-slider');
        const betAmountLabel = document.getElementById('bet-amount-label');
        const winnerDisplay = document.getElementById('winner-display');

        // --- WebSocket Logic ---
        function connectWebSocket() {
            addLogMessage("<strong>System:</strong> Attempting connection...", "system");
            websocket = new WebSocket(wsUrl);
            websocket.onopen = () => { addLogMessage("<strong>System:</strong> Connected! Enter name.", "system"); nameModal.style.display = 'flex'; nameInput.focus(); };
            websocket.onmessage = (event) => { try { const data = JSON.parse(event.data); console.log("Received:", data); handleServerMessage(data); } catch (e) { console.error("Msg err:", e); addLogMessage("<strong>System:</strong> Error processing msg.", "error"); }};
            websocket.onclose = (event) => { const r = event.reason ? ` Reason: ${event.reason}` : ''; addLogMessage(`<strong>System:</strong> Disconnected.${r} Retry 5s...`, "system"); disableAllActions(); clearTable(); myPlayerId = null; playerMap = {}; setTimeout(connectWebSocket, 5000); };
            websocket.onerror = (error) => { console.error("WS error:", error); addLogMessage("<strong>System:</strong> WS connection error.", "error"); };
        }
        function sendMessage(type, payload) {
            if (websocket && websocket.readyState === WebSocket.OPEN) { const msg = JSON.stringify({ type, payload }); console.log("Sending:", msg); websocket.send(msg); }
            else { addLogMessage("<strong>System:</strong> Cannot send: Not connected.", "error"); }
        }

        function handleServerMessage(data) {
            // Hide winner display on most messages, except state update during showdown
            if (data.type !== 'game_state' || (data.type === 'game_state' && data.payload.game_stage !== 'showdown')) { hideWinnerDisplay(); }

            switch (data.type) {
                case 'assign_id':
                    myPlayerId = data.payload.playerId; addLogMessage(`<strong>System:</strong> ID: ${myPlayerId}. Enter name.`, "system"); break;
                case 'game_state':
                    // ** FIX: Explicitly disable actions when receiving a general game state **
                    // Only 'player_turn' should enable them for the correct player.
                    if (actionArea.style.display !== 'none' && data.payload.current_player_id !== myPlayerId) {
                         console.log("GameState received, disabling actions as it's not my turn.");
                         disableAllActions();
                    }
                    updateUI(data.payload);
                    break;
                case 'player_turn':
                    console.log(`Player turn msg received for P${data.payload.playerId}. My ID is ${myPlayerId}.`); // DEBUG LOG
                    if (data.payload.playerId === myPlayerId) {
                        currentTurnOptions = data.payload; enableActions(data.payload); addLogMessage("<strong>Game:</strong> It's YOUR turn!", "game");
                    } else {
                        // Ensure actions are disabled if it's not our turn
                        disableAllActions();
                        const currentPlayer = playerMap[data.payload.playerId];
                        if (currentPlayer) { addLogMessage(`<strong>Game:</strong> Waiting for ${currentPlayer.name || `P${data.payload.playerId}`}...`, "game"); }
                    }
                    break;
                case 'game_message': addLogMessage(`<strong>Game:</strong> ${data.payload.message}`, "game"); break;
                case 'player_action':
                     const actor = playerMap[data.payload.playerId]; const name = actor ? actor.name : `P${data.payload.playerId}`;
                     let actMsg = `${data.payload.action}`; if (data.payload.amount != null) { actMsg += ` $${data.payload.amount}`; }
                     addLogMessage(`<strong>${name}:</strong> ${actMsg}`, "action"); break;
                 case 'pot_awarded': handlePotAwarded(data.payload); break;
                case 'showdown': handleShowdownReveal(data.payload); break; // Reveal cards only
                case 'error':
                    addLogMessage(`<strong>Error:</strong> ${data.payload.message}`, "error");
                    if (data.payload.message.includes("Not your turn")) { disableAllActions(); } // Disable if server explicitly says OOT
                    break;
                default: console.warn("Unknown msg type:", data.type); addLogMessage(`<strong>System:</strong> Unknown msg type '${data.type}'`, "system");
            }
        }

        // --- UI Update Logic ---
        function clearTable() {
            pokerTable.querySelectorAll('.player-area').forEach(a => a.remove());
            communityCardArea.innerHTML = '<span class="text-gray-400 text-sm italic">Disconnected</span>';
            potArea.textContent = 'Pot: $?'; hideWinnerDisplay();
        }
        function updateUI(state) {
            console.log("Updating UI with state:", state); playerMap = state.players || {};
            const pIds = Object.keys(playerMap); const myIdNum = parseInt(myPlayerId, 10);
            myPlayerIndex = pIds.findIndex(id => parseInt(id, 10) === myIdNum);
            pokerTable.querySelectorAll('.player-area').forEach(a => a.remove());
            const displayOrder = [];
            if (myPlayerIndex !== -1) { const rotIds = [...pIds.slice(myPlayerIndex), ...pIds.slice(0, myPlayerIndex)]; rotIds.forEach(pid => { if (playerMap[pid]) displayOrder.push(playerMap[pid]); }); }
            else { pIds.forEach(pid => { if (playerMap[pid]) displayOrder.push(playerMap[pid]); }); }
            displayOrder.forEach((p, i) => createOrUpdatePlayerArea(p, i, state.current_player_id));
            communityCardArea.innerHTML = '';
            if (state.community_cards && state.community_cards.length > 0) { state.community_cards.forEach(c => communityCardArea.appendChild(createCardElement(c))); }
            else if (state.game_stage && !['idle', 'starting', 'hand_over'].includes(state.game_stage)) { communityCardArea.innerHTML = `<span class="text-gray-400 text-sm italic">Waiting for ${state.game_stage}...</span>`; }
            else { communityCardArea.innerHTML = '<span class="text-gray-400 text-sm italic">Waiting for deal...</span>'; }
            potArea.textContent = `Pot: $${state.pot || 0}`;
            // If game stage indicates hand is over, ensure actions disabled (redundant check, but safe)
            if (['showdown', 'hand_over'].includes(state.game_stage) && actionArea.style.display !== 'none') { disableAllActions(); }
        }
        function createOrUpdatePlayerArea(p, displayIndex, currentPId) {
            const posClass = `player-pos-${displayIndex}`; let area = document.createElement('div');
            area.id = `player-area-${p.id}`; area.className = `player-area ${posClass}`; pokerTable.appendChild(area);
            const nameDiv = document.createElement('div'); nameDiv.className = 'player-name'; const dName = p.name || `P${p.id}`; nameDiv.textContent = dName + (p.id === myPlayerId ? ' (You)' : ''); nameDiv.title = dName; area.appendChild(nameDiv);
            const chipsDiv = document.createElement('div'); chipsDiv.className = 'player-chips'; chipsDiv.textContent = `$${p.stack ?? '?'}`; area.appendChild(chipsDiv);
            const cardsDiv = document.createElement('div'); cardsDiv.className = 'player-cards'; if (p.hand && p.hand.length > 0) { p.hand.forEach(c => cardsDiv.appendChild(createCardElement(c, c === '??'))); } area.appendChild(cardsDiv);
            const statusDiv = document.createElement('div'); statusDiv.className = 'player-status'; let statusTxt = ''; area.classList.remove('folded');
            if (p.status === 'folded') { statusTxt = 'Folded'; area.classList.add('folded'); }
            else if (p.status === 'all-in') { statusTxt = `All-in ($${p.current_bet || 0})`; }
            else if (p.current_bet > 0) { statusTxt = `Bet: $${p.current_bet}`; }
            else if (p.last_action && p.last_action !== 'blind') { statusTxt = p.last_action.charAt(0).toUpperCase() + p.last_action.slice(1); }
            statusDiv.textContent = statusTxt; area.appendChild(statusDiv);
            area.classList.remove('player-current', 'player-dealer'); if (p.id === parseInt(currentPId, 10)) area.classList.add('player-current'); if (p.is_dealer) area.classList.add('player-dealer');
        }
        function createCardElement(cardStr, isBack = false) {
            const cardDiv = document.createElement('div'); cardDiv.className = 'card';
            if (isBack || !cardStr || cardStr === "??") { cardDiv.classList.add('card-back'); cardDiv.innerHTML = '&nbsp;'; return cardDiv; }
            if (cardStr.length < 2) { console.warn("Invalid card:", cardStr); cardDiv.textContent = '?'; return cardDiv; }
            const rank = cardStr.slice(0, -1); const suit = cardStr.slice(-1); let sClass = '';
            switch (suit) { case '♥': sClass = 'heart'; break; case '♦': sClass = 'diamond'; break; case '♣': sClass = 'club'; break; case '♠': sClass = 'spade'; break; default: console.warn("Unknown suit:", suit); break; }
            cardDiv.textContent = rank + suit; if (sClass) cardDiv.classList.add(sClass); return cardDiv;
        }
        function handleShowdownReveal(payload) {
             addLogMessage(`<strong>Game:</strong> --- Showdown ---`, "game");
              if (payload.allHands) {
                 Object.entries(payload.allHands).forEach(([pid, hand]) => {
                     const area = document.getElementById(`player-area-${pid}`);
                     if (area) { const cardsC = area.querySelector('.player-cards'); if (cardsC && hand.length > 0) { cardsC.innerHTML = ''; hand.forEach(c => cardsC.appendChild(createCardElement(c))); area.classList.remove('folded'); }}
                     else { console.warn(`Showdown reveal: Area not found P${pid}`); }
                 });
             } else { console.warn("Showdown msg missing allHands."); }
             disableAllActions(); // Winner display handled by pot_awarded
        }
         function handlePotAwarded(payload) {
             console.log("Pot awarded:", payload);
             if (payload.winners && payload.winners.length > 0) {
                 showWinnerDisplay(payload.winners, payload.isUncontested);
                 payload.winners.forEach(w => {
                      const wName = w.playerName || playerMap[w.playerId]?.name || `P${w.playerId}`;
                      let wMsg = `<strong>${wName}</strong> wins $${w.amount}`;
                      if (!payload.isUncontested && w.handRank) { wMsg += ` with ${w.handRank}`; if(w.winningHand?.length > 0) { wMsg += `: ${w.winningHand.map(c => c === '??' ? '' : c).join(', ')}`; }}
                      else { wMsg += ` (Uncontested)`; }
                      addLogMessage(wMsg, "game");
                 });
             } else { addLogMessage("<strong>Game:</strong> Pot awarded msg received, no winner data.", "system"); }
             addLogMessage(`<strong>Game:</strong> --- Hand Over ---`, "game"); disableAllActions(); currentTurnOptions = null;
         }
         function showWinnerDisplay(winnersData, isUncontested) {
             if (!winnerDisplay) return; let html = '';
             if (winnersData?.length > 0) {
                 winnersData.forEach(w => { const wName = w.playerName || playerMap[w.playerId]?.name || `P${w.playerId}`; html += `<p>${wName} wins $${w.amount}`; if (!isUncontested && w.handRank) { html += ` <span class="hand-rank">(${w.handRank})</span>`; } html += `</p>`; });
                 if (winnersData.length > 1) html = `<p>Split Pot!</p>` + html;
             } else { html = '<p>Error: No winner info</p>'; }
             winnerDisplay.innerHTML = html; winnerDisplay.style.display = 'block';
             if (winnerDisplayTimeout) clearTimeout(winnerDisplayTimeout);
             winnerDisplayTimeout = setTimeout(hideWinnerDisplay, WINNER_DISPLAY_DURATION);
         }
         function hideWinnerDisplay() { if (winnerDisplay) winnerDisplay.style.display = 'none'; if (winnerDisplayTimeout) { clearTimeout(winnerDisplayTimeout); winnerDisplayTimeout = null; } }
        function addLogMessage(htmlMessage, type = "system") { const p = document.createElement('p'); p.className = `${type}-message`; p.innerHTML = `[${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })}] ${htmlMessage}`; messageLog.appendChild(p); messageLog.scrollTop = messageLog.scrollHeight; }

        // --- Action Handling ---
        function disableAllActions() {
            console.log("Disabling all actions");
            foldButton.disabled = true; checkButton.disabled = true; callButton.disabled = true; betButton.disabled = true; raiseButton.disabled = true;
            betSlider.disabled = true; betSliderContainer.style.display = 'none'; actionArea.style.display = 'none'; currentTurnOptions = null;
        }
        function enableActions(options) {
            console.log("Enabling actions with options:", options); actionArea.style.display = 'flex'; betSliderContainer.style.display = 'none';
            const actions = options.actions || []; const canFold = actions.includes('fold'); const canCheck = actions.includes('check'); const canCall = actions.includes('call'); const canBet = actions.includes('bet'); const canRaise = actions.includes('raise');
            const callAmt = options.callAmount || 0; const minBetRaise = options.minRaise || 0; const maxBetRaise = options.maxRaise || minBetRaise; const stack = options.stack || 0;
            foldButton.disabled = !canFold; checkButton.disabled = !canCheck; checkButton.style.display = canCheck ? 'inline-block' : 'none';
            callButton.disabled = !canCall; const displayCall = Math.min(callAmt, stack); callButton.textContent = `Call $${displayCall}`; callButton.style.display = canCall ? 'inline-block' : 'none';
            betButton.disabled = !canBet; betButton.style.display = canBet ? 'inline-block' : 'none'; raiseButton.disabled = !canRaise; raiseButton.style.display = canRaise ? 'inline-block' : 'none';
            if (canBet || canRaise) {
                betSliderContainer.style.display = 'flex'; betSlider.disabled = false;
                const min = minBetRaise; const max = maxBetRaise; const step = Math.max(1, Math.min(options.bigBlind || 10, Math.floor(max / 20)));
                 if (typeof min !== 'number' || isNaN(min) || typeof max !== 'number' || isNaN(max) || typeof step !== 'number' || isNaN(step) || step <= 0) {
                     console.error("Invalid slider vals:", {min, max, step}); addLogMessage("<strong>Error:</strong> Invalid bet range.", "error");
                     betSlider.min = 0; betSlider.max = 0; betSlider.step = 1; betSlider.value = 0; betSlider.disabled = true; betAmountLabel.textContent = "$??";
                 } else {
                     betSlider.min = min; betSlider.max = Math.max(min, max); betSlider.step = step; betSlider.value = min; betAmountLabel.textContent = `$${min}`; updateBetRaiseButtonText(min, canBet, canRaise);
                 }
            } else { betSliderContainer.style.display = 'none'; }
        }
        function updateBetRaiseButtonText(amount, canBet, canRaise) {
             const numAmt = parseInt(amount, 10); if (isNaN(numAmt)) return;
             if (canBet && betButton.style.display !== 'none') betButton.textContent = `Bet $${numAmt}`;
             if (canRaise && raiseButton.style.display !== 'none') raiseButton.textContent = `Raise to $${numAmt}`;
         }

        // Event Listeners
        nameSubmit.addEventListener('click', () => { const name = nameInput.value.trim().substring(0, 15); if (name && websocket?.readyState === WebSocket.OPEN && myPlayerId) { sendMessage("set_name", { name: name }); addLogMessage(`<strong>System:</strong> Name '${name}' submitted.`, "system"); nameModal.style.display = 'none'; } else if (!name) alert("Please enter a name."); else addLogMessage("<strong>System:</strong> Cannot set name.", "error"); });
        nameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); nameSubmit.click(); } });
        foldButton.addEventListener('click', () => { sendMessage("player_action", { action: "fold" }); disableAllActions(); });
        checkButton.addEventListener('click', () => { sendMessage("player_action", { action: "check" }); disableAllActions(); });
        callButton.addEventListener('click', () => { sendMessage("player_action", { action: "call" }); disableAllActions(); });
        betButton.addEventListener('click', () => { const amt = parseInt(betSlider.value, 10); console.log(`Bet click: ${amt}`); if (currentTurnOptions && !isNaN(amt)) { const minV = currentTurnOptions.minRaise || 0; const maxV = currentTurnOptions.maxRaise || 0; console.log(`Validating Bet: amt=${amt}, min=${minV}, max=${maxV}`); if (amt >= minV && amt <= maxV) { sendMessage("player_action", { action: "bet", amount: amt }); disableAllActions(); } else { addLogMessage(`<strong>Sys:</strong> Invalid bet ($${amt}). Min:${minV}, Max:${maxV}`, "error"); console.error("Invalid bet amt client:", {amt, minV, maxV}); } } else { addLogMessage(`<strong>Sys:</strong> Cannot bet - options/amt invalid.`, "error"); console.error("Cannot bet:", {currentTurnOptions, amt}); } });
        raiseButton.addEventListener('click', () => { const amt = parseInt(betSlider.value, 10); console.log(`Raise click: ${amt}`); if (currentTurnOptions && !isNaN(amt)) { const minV = currentTurnOptions.minRaise || 0; const maxV = currentTurnOptions.maxRaise || 0; console.log(`Validating Raise: amt=${amt}, min=${minV}, max=${maxV}`); if (amt >= minV && amt <= maxV) { sendMessage("player_action", { action: "raise", amount: amt }); disableAllActions(); } else { addLogMessage(`<strong>Sys:</strong> Invalid raise ($${amt}). Min:${minV}, Max:${maxV}`, "error"); console.error("Invalid raise amt client:", {amt, minV, maxV}); } } else { addLogMessage(`<strong>Sys:</strong> Cannot raise - options/amt invalid.`, "error"); console.error("Cannot raise:", {currentTurnOptions, amt}); } });
        betSlider.addEventListener('input', () => { const amt = parseInt(betSlider.value, 10); if (isNaN(amt)) return; betAmountLabel.textContent = `$${amt}`; if (currentTurnOptions) { updateBetRaiseButtonText(amt, currentTurnOptions.actions.includes('bet'), currentTurnOptions.actions.includes('raise')); } });

        // --- Initial Connection ---
        disableAllActions(); hideWinnerDisplay(); connectWebSocket();
    </script>

</body>
</html>
<!-- ```

**Changes Made:**

1.  **`handleServerMessage`:** Added a check at the beginning of the `game_state` case. If the action bar is currently visible (`actionArea.style.display !== 'none'`) and the `current_player_id` in the received state *is not* the client's `myPlayerId`, it now explicitly calls `disableAllActions()`.
2.  **Debug Log:** Added a `console.log` in the `player_turn` handler to clearly show the received `playerId` and the client's `myPlayerId` during the comparison.

This should prevent the action bar from staying visible when a general game update occurs and it's no longer your turn. Test this version, and hopefully, the action bar will behave correctly n -->